<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Paired Image Viewer (File + URL)</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .controls {
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      font-size: 14px;
    }

    .controls > div {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .controls label {
      font-weight: 500;
    }

    input[type="file"] {
      font-size: 12px;
    }

    input[type="text"] {
      width: 260px;
      padding: 2px 4px;
      font-size: 12px;
    }

    button {
      font-size: 12px;
      padding: 2px 8px;
      cursor: pointer;
    }

    #viewerContainer {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1px;
      background: #ccc;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #111;
      cursor: grab;
    }

    canvas:active {
      cursor: grabbing;
    }

    .status {
      margin-left: auto;
      font-size: 12px;
      color: #555;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div class="controls">
    <!-- LEFT -->
    <div>
      <label>Left image (local):</label>
      <input id="fileLeft" type="file" accept=".png,.jpg,.jpeg,.webp">
    </div>

    <div>
      <label>Left image URL (cloud):</label>
      <div style="display:flex; gap:4px;">
        <input id="urlLeft" type="text" placeholder="https://.../left.png">
        <button id="btnLoadLeftUrl">Load left URL</button>
      </div>
    </div>

    <!-- RIGHT -->
    <div>
      <label>Right image (local):</label>
      <input id="fileRight" type="file" accept=".png,.jpg,.jpeg,.webp">
    </div>

    <div>
      <label>Right image URL (cloud):</label>
      <div style="display:flex; gap:4px;">
        <input id="urlRight" type="text" placeholder="https://.../right.png">
        <button id="btnLoadRightUrl">Load right URL</button>
      </div>
    </div>

    <span class="status" id="status">Load two images (same size) to begin</span>
  </div>

  <div id="viewerContainer">
    <canvas id="canvasLeft"></canvas>
    <canvas id="canvasRight"></canvas>
  </div>

  <script>
    // DOM refs
    const fileLeft = document.getElementById('fileLeft');
    const fileRight = document.getElementById('fileRight');
    const urlLeft  = document.getElementById('urlLeft');
    const urlRight = document.getElementById('urlRight');
    const btnLoadLeftUrl  = document.getElementById('btnLoadLeftUrl');
    const btnLoadRightUrl = document.getElementById('btnLoadRightUrl');

    const canvasLeft = document.getElementById('canvasLeft');
    const canvasRight = document.getElementById('canvasRight');
    const statusEl = document.getElementById('status');

    // Images and shared view state
    let imgLeft = null;
    let imgRight = null;
    let imgWidth = null;
    let imgHeight = null;

    let scale = 1.0;
    let offsetX = 0;
    let offsetY = 0;

    let isPanning = false;
    let lastX = 0;
    let lastY = 0;

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function setLoadedImage(img, side) {
      const w = img.width;
      const h = img.height;

      if (!imgWidth || !imgHeight) {
        // first loaded image defines reference size
        imgWidth = w;
        imgHeight = h;
        setStatus(`Image size: ${imgWidth} × ${imgHeight}px`);
      } else if (w !== imgWidth || h !== imgHeight) {
        alert(
          `The two images must have the same size.\n` +
          `First: ${imgWidth}×${imgHeight}, new: ${w}×${h}`
        );
        return;
      }

      if (side === 'left') {
        imgLeft = img;
      } else {
        imgRight = img;
      }

      resetView();
      draw();
    }

    // ---------- Load from local file ----------

    function loadFromFile(file, side) {
      const reader = new FileReader();
      reader.onload = e => {
        const img = new Image();
        img.onload = () => setLoadedImage(img, side);
        img.onerror = () => {
          alert("Failed to decode local image. Use PNG/JPEG/WEBP.");
        };
        img.src = e.target.result; // data URL
      };
      reader.readAsDataURL(file);
    }

    fileLeft.addEventListener('change', e => {
      if (e.target.files && e.target.files[0]) {
        loadFromFile(e.target.files[0], 'left');
      }
    });

    fileRight.addEventListener('change', e => {
      if (e.target.files && e.target.files[0]) {
        loadFromFile(e.target.files[0], 'right');
      }
    });

    // ---------- Load from URL (cloud/Box/GitHub/etc.) ----------

    function loadFromUrl(url, side) {
      if (!url) {
        alert("Please enter an image URL.");
        return;
      }
      const img = new Image();
      // For some hosts, if you later want to export canvas, you might need:
      // img.crossOrigin = "anonymous";

      img.onload = () => setLoadedImage(img, side);
      img.onerror = () => {
        alert("Failed to load image from URL. Check the URL and permissions (Box sharing settings).");
      };
      img.src = url;
    }

    btnLoadLeftUrl.addEventListener('click', () => {
      loadFromUrl(urlLeft.value.trim(), 'left');
    });

    btnLoadRightUrl.addEventListener('click', () => {
      loadFromUrl(urlRight.value.trim(), 'right');
    });

    // ---------- Viewer / canvas logic ----------

    function resizeCanvases() {
      const rectL = canvasLeft.getBoundingClientRect();
      const rectR = canvasRight.getBoundingClientRect();

      if (canvasLeft.width !== rectL.width || canvasLeft.height !== rectL.height) {
        canvasLeft.width = rectL.width;
        canvasLeft.height = rectL.height;
      }
      if (canvasRight.width !== rectR.width || canvasRight.height !== rectR.height) {
        canvasRight.width = rectR.width;
        canvasRight.height = rectR.height;
      }
    }

    function resetView() {
      if (!imgWidth || !imgHeight) return;

      resizeCanvases();
      const rect = canvasLeft.getBoundingClientRect();

      const scaleX = rect.width / imgWidth;
      const scaleY = rect.height / imgHeight;
      scale = Math.min(scaleX, scaleY);

      offsetX = (rect.width - imgWidth * scale) / 2;
      offsetY = (rect.height - imgHeight * scale) / 2;
    }

    function drawOne(ctx, canvas, img) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!img) return;

      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      ctx.drawImage(img, 0, 0);
    }

    function draw() {
      resizeCanvases();
      const ctxL = canvasLeft.getContext('2d');
      const ctxR = canvasRight.getContext('2d');

      drawOne(ctxL, canvasLeft, imgLeft);
      drawOne(ctxR, canvasRight, imgRight);

      if (imgWidth && imgHeight) {
        setStatus(`Zoom: ${(scale * 100).toFixed(1)}%`);
      }
    }

    function getCanvasCoords(canvas, event) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }

    function handleWheel(canvas, event) {
      if (!imgWidth || !imgHeight) return;
      event.preventDefault();

      const { x, y } = getCanvasCoords(canvas, event);
      const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;
      const newScale = scale * zoomFactor;

      const minScale = 0.05;
      const maxScale = 20;
      if (newScale < minScale || newScale > maxScale) return;

      const worldX = (x - offsetX) / scale;
      const worldY = (y - offsetY) / scale;

      scale = newScale;
      offsetX = x - worldX * scale;
      offsetY = y - worldY * scale;

      draw();
    }

    function handleMouseDown(canvas, event) {
      if (!imgWidth || !imgHeight) return;
      isPanning = true;
      const { x, y } = getCanvasCoords(canvas, event);
      lastX = x;
      lastY = y;
    }

    function handleMouseMove(canvas, event) {
      if (!isPanning) return;
      const { x, y } = getCanvasCoords(canvas, event);
      const dx = x - lastX;
      const dy = y - lastY;
      lastX = x;
      lastY = y;

      offsetX += dx;
      offsetY += dy;

      draw();
    }

    function handleMouseUp() {
      isPanning = false;
    }

    function attachInteractions(canvas) {
      canvas.addEventListener('wheel', e => handleWheel(canvas, e), { passive: false });
      canvas.addEventListener('mousedown', e => handleMouseDown(canvas, e));
      canvas.addEventListener('mousemove', e => handleMouseMove(canvas, e));
      window.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('mouseleave', handleMouseUp);
    }

    attachInteractions(canvasLeft);
    attachInteractions(canvasRight);

    window.addEventListener('resize', () => {
      if (imgWidth && imgHeight) {
        draw();
      } else {
        resizeCanvases();
      }
    });

    // Init
    resizeCanvases();
  </script>
</body>
</html>
